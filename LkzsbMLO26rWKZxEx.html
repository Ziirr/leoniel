<html><head><base href="."><link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet"><style>@font-face {font-family: 'Press Start 2P';src: url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');}body {background: #0f0f0f;display: flex;flex-direction: column;align-items: center;font-family: 'Press Start 2P', cursive;color: #00ff00;text-shadow: 2px 2px #003300;padding: 20px;}#game-container {margin: 20px;display: flex;gap: 20px;align-items: flex-start;background: #000;padding: 20px;border: 4px solid #666;border-style: ridge;}canvas {border: 4px solid #666;border-style: inset;image-rendering: pixelated;}#next-piece {width: 80px;height: 80px;border: 4px solid #666;border-style: inset;image-rendering: pixelated;}.controls {margin: 20px;padding: 15px;background: #000;border: 4px solid #666;border-style: ridge;font-size: 8px;line-height: 1.5;}.score {font-size: 16px;margin: 10px;color: #00ff00;text-shadow: 2px 2px #003300;}.preview-container {background: #000;padding: 10px;border: 4px solid #666;border-style: ridge;}.preview-label {text-align: center;margin-bottom: 5px;font-size: 8px;}.game-over {position: fixed;top: 0;left: 0;width: 100%;height: 100%;background: rgba(0, 0, 0, 0.9);display: none;justify-content: center;align-items: center;flex-direction: column;z-index: 100;}.title-screen {position: fixed;top: 0;left: 0;width: 100%;height: 100%;background: #000;display: flex;justify-content: center;align-items: center;flex-direction: column;z-index: 200;}.title-screen h1 {color: #00ff00;font-size: 48px;margin-bottom: 40px;text-shadow: 4px 4px #003300;text-align: center;}.title-screen.hidden {display: none;}.title-screen button {padding: 15px 30px;font-size: 20px;background: #000;color: #00ff00;border: 4px solid #666;border-style: outset;cursor: pointer;font-family: 'Press Start 2P', cursive;text-shadow: 2px 2px #003300;margin: 10px;}.title-screen button:hover {background: #003300;}.title-screen button:active {border-style: inset;}.blink {animation: blink 1s infinite;}@keyframes blink {0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; }}.game-over.active {display: flex;}.game-over h1 {color: #ff0000;font-size: 32px;margin-bottom: 20px;text-shadow: 2px 2px #330000;}.game-over button {padding: 10px 20px;font-size: 16px;background: #000;color: #00ff00;border: 4px solid #666;border-style: outset;cursor: pointer;font-family: 'Press Start 2P', cursive;text-shadow: 2px 2px #003300;}.game-over button:hover {background: #003300;}.game-over button:active {border-style: inset;}.flash-line {animation: flashLine 0.2s linear;}@keyframes flashLine {0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; }}</style></head><body><div class="score">Score: <span id="score">0</span></div><div id="game-container"><canvas id="tetris" width="240" height="400"></canvas><div class="preview-container"><div class="preview-label">Next:</div><canvas id="next-piece" width="80" height="80"></canvas></div></div><div class="controls">Controls:<br>← → : Move left/right<br>↓ : Drop faster<br>↑ : Rotate piece<br>Space : Instant drop</div><div class="game-over" id="gameOver"><div class="title-screen" id="titleScreen"><h1>TETRIS</h1><button onclick="startGame()">START GAME</button><p class="blink">PRESS START</p></div><h1>GAME OVER</h1><button onclick="resetGame()">Play Again</button></div><script>const canvas = document.getElementById('tetris');const context = canvas.getContext('2d');const nextPieceCanvas = document.getElementById('next-piece');const nextPieceContext = nextPieceCanvas.getContext('2d');const scoreElement = document.getElementById('score');context.scale(20, 20);nextPieceContext.scale(20, 20);function sweep() {return new Promise((resolve) => {let rowCount = 1;let rowsToAnimate = [];outer: for (let y = arena.length - 1; y > 0; --y) {for (let x = 0; x < arena[y].length; ++x) {if (arena[y][x] === 0) {continue outer;}}rowsToAnimate.push(y);}if (rowsToAnimate.length > 0) {let flashCount = 0;const maxFlashes = 3;const flashInterval = setInterval(() => {rowsToAnimate.forEach(y => {for (let x = 0; x < arena[0].length; x++) {const colors = [null,'#FF0000','#0000FF','#00FF00','#FF00FF','#FFFF00','#00FFFF','#FF8800'];context.fillStyle = flashCount % 2 === 0 ? colors[arena[y][x]] : '#FFFFFF';context.fillRect(x, y, 1, 1);}});flashCount++;if (flashCount >= maxFlashes * 2) {clearInterval(flashInterval);rowsToAnimate.sort((a, b) => b - a);rowsToAnimate.forEach(y => {const row = arena.splice(y, 1)[0].fill(0);arena.unshift(row);});player.score += rowsToAnimate.length * rowCount * 10;rowCount *= 2;updateScore();resolve();}}, 100);} else {resolve();}});}function collide(arena, player) {const [m, o] = [player.matrix, player.pos];for (let y = 0; y < m.length; ++y) {for (let x = 0; x < m[y].length; ++x) {if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {return true;}}}return false;}function createMatrix(w, h) {const matrix = [];while (h--) {matrix.push(new Array(w).fill(0));}return matrix;}function createPiece(type) {if (type === 'T') {return [[0, 0, 0],[1, 1, 1],[0, 1, 0],];} else if (type === 'O') {return [[2, 2],[2, 2],];} else if (type === 'L') {return [[0, 3, 0],[0, 3, 0],[0, 3, 3],];} else if (type === 'J') {return [[0, 4, 0],[0, 4, 0],[4, 4, 0],];} else if (type === 'I') {return [[0, 5, 0, 0],[0, 5, 0, 0],[0, 5, 0, 0],[0, 5, 0, 0],];} else if (type === 'S') {return [[0, 6, 6],[6, 6, 0],[0, 0, 0],];} else if (type === 'Z') {return [[7, 7, 0],[0, 7, 7],[0, 0, 0],];}}function calculateGhostPosition() {const ghost = {pos: { x: player.pos.x, y: player.pos.y },matrix: player.matrix};while (!collide(arena, ghost)) {ghost.pos.y++;}ghost.pos.y--;return ghost;}function draw() {context.fillStyle = '#000';context.fillRect(0, 0, canvas.width, canvas.height);drawMatrix(arena, {x: 0, y: 0});const ghost = calculateGhostPosition();ghost.matrix.forEach((row, y) => {row.forEach((value, x) => {if (value !== 0) {context.fillStyle = 'rgba(255, 255, 255, 0.2)';context.fillRect(x + ghost.pos.x, y + ghost.pos.y, 1, 1);context.fillStyle = 'rgba(255, 255, 255, 0.3)';context.fillRect(x + ghost.pos.x, y + ghost.pos.y, 0.125, 1);context.fillRect(x + ghost.pos.x, y + ghost.pos.y, 1, 0.125);context.fillRect(x + ghost.pos.x + 0.875, y + ghost.pos.y, 0.125, 1);context.fillRect(x + ghost.pos.x, y + ghost.pos.y + 0.875, 1, 0.125);}}});drawMatrix(player.matrix, player.pos);}function drawMatrix(matrix, offset) {matrix.forEach((row, y) => {row.forEach((value, x) => {if (value !== 0) {const colors = [null,'#FF0000','#0000FF','#00FF00','#FF00FF','#FFFF00','#00FFFF','#FF8800'];context.fillStyle = colors[value];context.fillRect(x + offset.x, y + offset.y, 1, 1);context.fillStyle = '#FFFFFF';context.fillRect(x + offset.x, y + offset.y, 0.125, 1);context.fillRect(x + offset.x, y + offset.y, 1, 0.125);context.fillStyle = '#000000';context.fillRect(x + offset.x + 0.875, y + offset.y, 0.125, 1);context.fillRect(x + offset.x, y + offset.y + 0.875, 1, 0.125);}});});}function merge(arena, player) {player.matrix.forEach((row, y) => {row.forEach((value, x) => {if (value !== 0) {arena[y + player.pos.y][x + player.pos.x] = value;}});});}async function playerDrop() {player.pos.y++;if (collide(arena, player)) {player.pos.y--;merge(arena, player);await sweep();await playerReset();updateScore();}dropCounter = 0;}function playerMove(dir) {player.pos.x += dir;if (collide(arena, player)) {player.pos.x -= dir;}}function drawNextPiece() {nextPieceContext.fillStyle = '#000';nextPieceContext.fillRect(0, 0, 4, 4);if (nextPiece) {nextPiece.forEach((row, y) => {row.forEach((value, x) => {if (value !== 0) {const colors = [null,'#FF0000','#0000FF','#00FF00','#FF00FF','#FFFF00','#00FFFF','#FF8800'];nextPieceContext.fillStyle = colors[value];nextPieceContext.fillRect(x + 0.5, y + 0.5, 1, 1);nextPieceContext.fillStyle = '#FFFFFF';nextPieceContext.fillRect(x + 0.5, y + 0.5, 0.125, 1);nextPieceContext.fillRect(x + 0.5, y + 0.5, 1, 0.125);nextPieceContext.fillStyle = '#000000';nextPieceContext.fillRect(x + 0.5 + 0.875, y + 0.5, 0.125, 1);nextPieceContext.fillRect(x + 0.5, y + 0.5 + 0.875, 1, 0.125);}});});}}async function showGameOver() {await gameOverAnimation();document.getElementById('gameOver').classList.add('active');}function gameOverAnimation() {return new Promise(resolve => {let currentLine = arena.length - 1;const animationInterval = setInterval(() => {if (currentLine >= 0) {arena[currentLine].fill(0);draw();currentLine--;} else {clearInterval(clearInterval);resolve();}}, 50);});}async function resetGame() {document.getElementById('gameOver').classList.remove('active');document.getElementById('titleScreen').classList.add('hidden');arena.forEach(row => row.fill(0));player.score = 0;updateScore();nextPiece = null;await playerReset();dropInterval = 1000;}function startGame() {document.getElementById('titleScreen').classList.add('hidden');resetGame();}async function playerReset() {if (nextPiece === null) {const pieces = 'TOLJISZ';player.matrix = createPiece(pieces[pieces.length * Math.random() | 0]);nextPiece = createPiece(pieces[pieces.length * Math.random() | 0]);} else {player.matrix = nextPiece;const pieces = 'TOLJISZ';nextPiece = createPiece(pieces[pieces.length * Math.random() | 0]);}player.pos.y = 0;player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);if (collide(arena, player)) {await showGameOver();arena.forEach(row => row.fill(0));player.score = 0;updateScore();}drawNextPiece();}function playerRotate(dir) {const pos = player.pos.x;let offset = 1;rotate(player.matrix, dir);while (collide(arena, player)) {player.pos.x += offset;offset = -(offset + (offset > 0 ? 1 : -1));if (offset > player.matrix[0].length) {rotate(player.matrix, -dir);player.pos.x = pos;return;}}}function rotate(matrix, dir) {for (let y = 0; y < matrix.length; ++y) {for (let x = 0; x < y; ++x) {[matrix[x][y],matrix[y][x]] = [matrix[y][x],matrix[x][y]];}}if (dir > 0) {matrix.forEach(row => row.reverse());} else {matrix.reverse();}}async function playerInstantDrop() {while (!collide(arena, player)) {player.pos.y++;}if (player.pos.y > 0) {player.pos.y--;merge(arena, player);await sweep();await playerReset();updateScore();dropCounter = 0;}}let dropCounter = 0;let dropInterval = 1000;let lastTime = 0;async function update(time = 0) {const deltaTime = time - lastTime;lastTime = time;dropCounter += deltaTime;if (dropCounter > dropInterval) {await playerDrop();}draw();drawNextPiece();requestAnimationFrame(update);}function updateScore() {scoreElement.innerText = player.score;}const arena = createMatrix(12, 20);const player = {pos: {x: 0, y: 0},matrix: null,score: 0,};let nextPiece = null;document.addEventListener('keydown', event => {if (event.keyCode === 37) {playerMove(-1);} else if (event.keyCode === 39) {playerMove(1);} else if (event.keyCode === 40) {playerDrop();} else if (event.keyCode === 38) {playerRotate(1);} else if (event.keyCode === 32) {event.preventDefault();playerInstantDrop();}});playerReset();updateScore();update();</script></body></html>